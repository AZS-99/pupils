package com.company;
/*
A promenade is a way of uniquely representing a fraction by a succession of “left or right” choices. As successive
choices are made the value of the promenade changes by combining the values of the promenade before the most recent
left choice with the value before the most recent right choice.

If the value before the most recent left choice was l/m and the value before the most recent right choice was r/s then
the new value will be (l+r) / (m+s). If there has never been a left choice we use l=1 and m=0; if there has never been
a right choice we use r=0 and s=1.

Fractions are always used in their lowest form; recall that a/b is in its lowest form if it is not possible to divide
a and b by a common factor. Values generated by the formula will automatically be in their lowest form. Fractions are
allowed to have a larger than b.
We will write our promenades as a sequence of Ls (for left choices) and Rs (for right choices).

For example, to form the promenade LRLL (using ∅ to represent the promenade before any choices are made):
• The value of ∅ is (1+0)/(0+1) = 1/1;
• The value of L is 1/2. Before the most recent left choice we had ∅ (= 1/1). There has not yet been a
right choice, so we use r=0 and s=1. So the value of L is (1+0)/(1+1) = 1/2;
• LR = 2/3 as we use the values of ∅ (before the left choice) and L (before the right choice);
• LRL = 3/5 as we use the values of LR and L;
• LRLL = 4/7 as we use the values of LRL and L.

Sample Run
LRLL
4/7

Sample run 2
RL
3/2
 */
public class Promenade {

    public static int[] promenade(String instructions) {
        if (instructions.equals("")) {
            return new int[] {1, 1};
        }
        var prev = promenade(instructions.substring(0, instructions.length()-1));
        if (instructions.charAt(instructions.length()-1) == 'L') {
            int rIndex = instructions.lastIndexOf('R');
            int[] rPrev;
            if (rIndex == -1) rPrev = new int[] {0, 1};
            else rPrev = promenade(instructions.substring(0, rIndex));
            return new int[] {prev[0] + rPrev[0], prev[1] + rPrev[1]};
        }
        int lIndex = instructions.lastIndexOf('L');
        int[] lPrev;
        if (lIndex == -1) lPrev = new int[] {1, 0};
        else lPrev = promenade(instructions.substring(0, lIndex));
        return new int[] {prev[0] + lPrev[0], prev[1] + lPrev[1]};
    }

}


//        var L = new int[] {1, 0};
//        var R = new int[] {0, 1};
//        var result = new int[] {1, 1};
//        var prevL
//        for (int i = 0; i < instructions.length(); i++) {
//            if (instructions.charAt(i) == 'L') {
//
//            }
//        }